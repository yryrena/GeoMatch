# GeoMatch.jl

[![ci](https://github.com/yryrena/GeoMatch/actions/workflows/ci.yml/badge.svg)](https://github.com/yryrena/GeoMatch/actions/workflows/ci.yml)

Minimal, working proof-of-concept for spatial matching in Julia.

Given a **treated** table and a **control** table with point geometries (WGS84 lon/lat), GeoMatch builds matched pairs or weighted sets based on great-circle distance, with optional covariate balancing diagnostics.

**MVP scope:** haversine distance, K-nearest neighbors or kernel matching, basic balance table, tiny HTML report, and a one-click CSV runner.

------

## Features

- Haversine distance on lon-lat coordinates
- K-nearest neighbor matching with or without replacement
- Kernel matching with Gaussian or triangular kernels
- Optional radius caliper and same-region constraint
- Simple balance diagnostics (standardized mean differences)
- Minimal HTML report generator
- One-click CSV runner: `examples/run_from_csv.jl`
- Robust column-name handling: case-insensitive; trims BOM/nbsp; collapses whitespace; converts spaces to `_`

------

## Status

- Tested on Julia **1.11**
- Core dependencies: `DataFrames`, `Distances`, `NearestNeighbors`, `StatsBase`, `StatsModels`, `GLM`, `GeoInterface`
- Examples/utilities: `CSV`, `GeometryBasics`, `PrettyTables` (optional), `Plots` (optional), `CategoricalArrays` (Love plot ordering)

**Note:** Geometries are passed via a `geometry` column containing `GeometryBasics.Point` values.

------

## Installation

From a local checkout:

```julia
julia> ]
(@v1.11) pkg> dev /path/to/GeoMatch
(@v1.11) pkg> test GeoMatch
```

From GitHub: 

```julia
julia> ]
(@v1.11) pkg> add https://github.com/yryrena/GeoMatch.git
(@v1.11) pkg> test GeoMatch
```

> Recommendation: do not commit `Manifest.toml` for a package repo. 

---

## One-Click CSV Runner

Run matching end-to-end from CSV files. The script is resilient to common CSV quirks (header case, extra spaces, BOM).

```bash
## simplest: looks for data/treated.csv and data/control.csv
julia --project=. examples/run_from_csv.jl
```

### With environment overrides

```bash
T_CSV=data/treated.csv \
C_CSV=data/control.csv \
COVARS=a,b \
GEO_LON=lon GEO_LAT=lat \
METHOD=kernel BANDWIDTH=500 K=3 RADIUS_KM=2000 REPLACE=true \
julia --project=. examples/run_from_csv.jl
```

**Environment variables**

- `T_CSV`, `C_CSV` - paths to input CSVs
   (default: falls back to `data/treated.csv` / `data/control.csv`, else `treated.csv` / `control.csv`)
- `GEO_LON`, `GEO_LAT` - longitude/latitude column names (default: `lon`, `lat`)
   *Case-insensitive; spaces normalized.*
- `COVARS` - comma-separated covariates used for diagnostics (e.g., `a,b`); **required** by API
- `METHOD` - `"geoNN"` or `"kernel"` (default: `"geoNN"`)
- `K` - matches per treated (default: `1`)
- `RADIUS_KM` - optional distance cap (e.g., `2000`)
- `BANDWIDTH` - required if `METHOD=kernel` (distance units = km)
- `REPLACE` - `true/false` for KNN reuse (default: `false`)

**Outputs**

- `pairs.csv` - matched pairs / weights (`t_id, c_id, distance, weight`)
- `balance.html` - standardized mean differences (before/after)
  - If `PrettyTables` isn't available, writes `balance.csv` instead
- `balance_loveplot.png` - Love plot (if `Plots` available)

---

## Quick Start (Julia API)

```julia
using DataFrames
using GeometryBasics       ## for Point(x, y)
using GeoMatch

## treated table
t = DataFrame(
    id = 1:3,
    lon = [116.4, 116.5, 116.6],
    lat = [39.90, 39.92, 39.95],
    income = 50 .+ 10*rand(3),
    pop    = 20 .+  5*rand(3)
)
t.geometry = [GeometryBasics.Point(t.lon[i], t.lat[i]) for i in 1:nrow(t)]

## control table
c = DataFrame(
    id = 101:130,
    lon = 116.1 .+ rand(30),
    lat =  39.7 .+ 0.6*rand(30),
    income = 48 .+ 10*rand(30),
    pop    = 22 .+  5*rand(30)
)
c.geometry = [GeometryBasics.Point(c.lon[i], c.lat[i]) for i in 1:nrow(c)]

## matching
res = GeoMatch.match_spatial(
    t, c;
    covars = [:income, :pop],
    method = "geoNN",      ## or "kernel"
    k = 2,
    radius_km = 50.0,
    distance_metric = :haversine,
    replace = false
)

## diagnostics
bt = GeoMatch.balance_table(res, t, c, [:income, :pop])

## report
GeoMatch.html_report("geomatch_report.html", res, bt)
```

Example output for `res.pairs`:

```text
6x4 DataFrame
 Row | t_id  c_id  distance  weight
     | Int64 Int64 Float64   Float64
-----+-------------------------------
   1 |     1    16   6.88871     1.0
   2 |     1    19  11.76730     1.0
   3 |     2    10   8.28476     1.0
   4 |     2    22   8.51346     1.0
   5 |     3    26   5.95047     1.0
   6 |     3     7   8.30584     1.0
```
```bash
julia --project=. examples/kernel.jl
julia --project=. examples/hybrid.jl
```

- `kernel.jl` shows spatial kernel matching with a Gaussian kernel (`method="kernel"`, `k=5`, `bandwidth=12.0` km).
- `hybrid.jl` shows geo K-NN with propensity-score refinement (`hybrid=true`, `ps_formula=@formula(treat ~ income + pop + urban)`).

Reports are saved as `geomatch_kernel.html` and `geomatch_hybrid.html`.

------

## API

#### `match_spatial(treated, control; kwargs...) -> MatchResult`

**Inputs**

- `treated::AbstractDataFrame`, `control::AbstractDataFrame`
   Must each contain a `geometry` column with `GeometryBasics.Point` values whose `.x`/`.y` are lon/lat (WGS84).
- `covars::Vector{Symbol}`
   Covariates for balance reporting and (future) hybrid/PS use. **Cannot be empty.**
- `method::String = "geoNN"`
  - `"geoNN"`: KNN matching on distance
  - `"kernel"`: distance-weighted matching using kernels
- `k::Int = 1` - matches per treated (for `"kernel"`, k nearest controls to compute weights)
- `radius_km::Union{Nothing,Float64} = nothing` - optional radius cap
- `kernel::String = "gaussian"` - `"gaussian"` or `"triangular"` (only for `method="kernel"`)
- `bandwidth::Union{Nothing,Float64} = nothing` - **required** if `method="kernel"`
- `hybrid::Bool = false`, `ps_formula = nothing` - reserved hooks for propensity refinement
- `region_col::Union{Nothing,Symbol} = nothing` - optional same-region constraint
- `distance_metric::Symbol = :haversine` - (MVP) only `:haversine`
- `crs_target::Union{Nothing,String} = nothing` - reserved for future CRS transforms
- `replace::Bool = false` - allow reuse of controls in KNN
- `seed::Union{Nothing,Int} = nothing` - RNG seed (unused in deterministic KNN)

**Output: `MatchResult`**

- `pairs::DataFrame` with columns:
  - `:t_id` (treated row index, 1-based)
  - `:c_id` (control row index, 1-based)
  - `:distance` (km)
  - `:weight` (1.0 for KNN; kernel weights for `"kernel"`)
- `dropped_treated::Vector{Int}` - treated units with no valid matches
- `dropped_control::Vector{Int}` - control units never used
- `config::MatchConfig` - echo of settings
- `summary::Dict{String,Any}` - basic counts/settings

---

#### `balance_table(res, treated, control, covars) -> DataFrame`

Returns standardized mean differences before/after matching (control side weighted when applicable).

Columns: `:var`, `:smd_before`, `:smd_after`.

---

#### `html_report(path, res, balance) -> String`

Writes a minimal HTML file with a run summary and the balance table. Returns the written `path`.

------

#### `love_plot(bt; outfile="balance_loveplot.png") -> String`

Generates a Love plot (absolute SMD before/after) and writes it to `outfile`. Requires `Plots`. The function is exported as `GeoMatch.love_plot`.

The implementation tolerates `Symbol`/`String` column names and orders variables by the maximum absolute SMD.

------

## Tests

A minimal test suite is included:

```
julia --project=. -e 'using Pkg; Pkg.test()'
```

The tests build tiny treated/control tables, run matching, and ensure:

- pairs are produced,
- balance table has the expected columns,
- the Love plot (if `Plots` installed) can be rendered.

---

## Troubleshooting

- **"`treated.csv` is not a valid file or doesn't exist"**
   Provide `T_CSV`/`C_CSV` or place files under `data/`.
- **"treated is missing column lon/lat"**
   Header names are normalized (case-insensitive, spaces to `_`).
   Pass `GEO_LON`/`GEO_LAT` if your headers are nonstandard (e.g., `Longitude`, `Lat Deg`).
- **"`covars must not be empty`"**
   The API requires covariates. For the runner, pass `COVARS=a,b` (comma-separated).
- **PrettyTables HTML kwargs**
   We use `stand_alone` / `wrap_table_in_div` (current PrettyTables HTML backend).
   Older `standalone` keyword is not used.
- **Love plot dependency**
   `CategoricalArrays` is required by the plotting helper to preserve ordering; it's included in `Project.toml`.

------

## Design Notes

- Geometry construction: prefer `GeometryBasics.Point(lon, lat)` for WGS84 points.
- Distance: haversine in kilometers. Projections/alternative metrics are future work.
- Determinism: KNN is deterministic given data/constraints; kernel weights are deterministic for the chosen neighbors.
- Performance: the MVP computes a dense distance matrix; for large `n x m`, tiling/ANN can be added later.

---

## Roadmap

- Optional CRS transforms and planar distances
- Exact calipers on covariates / propensity score
- Ratio matching and optimal assignment
- Richer diagnostics and plots
- Benchmarks and large-n strategies
